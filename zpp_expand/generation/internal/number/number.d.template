{{with $ctx :=  .}}class Native {
    private constructor()
    private readonly __Native: Native
    /**
     * get native field only work for struct to get numbers value without loss of precision
     * @param field 
     */
    get(field: string): any
}
function NewAsyncController(): AsyncController
class AsyncController extends Native {
    private constructor()
    private readonly __AsyncController: AsyncController
    Async(): boolean
    Complete(): boolean
    Call(f: () => void)
}
class GoUintptr extends Native {
    private readonly __GoUintptr: GoUintptr
    private constructor()
}
class GoNumber extends Native {
    private constructor()
    private readonly __GoNumber: GoNumber
}
type NumberLike = number | string | null | undefined | GoNumber

interface GoReadChannel<T> extends Native {
    private readonly __iGoReadChannel: GoReadChannel<T>
}
interface GoWriteChannel<T> extends Native {
    private readonly __iWriteChannel: GoWriteChannel<T>
}
interface GoChannel<T> extends Native implements GoReadChannel<T>, GoWriteChannel<T> {}
function goRecv<T>(ch: GoReadChannel<T>): [T, boolean]
function goTryRecv<T>(ch: GoReadChannel<T>): [T, boolean]
function goSend<T>(ch: GoWriteChannel<T>, x: any)
function goTrySend<T>(ch: GoWriteChannel<T>, x: any): boolean
function goClose<T>(ch: GoWriteChannel<T>)
function goRecv<T>(ch: GoReadChannel<T>, scheduler: Scheduler): Promise<[T, boolean]>
function goTryRecv<T>(ch: GoReadChannel<T>, scheduler: Scheduler): Promise<[T, boolean]>
function goSend<T>(ch: GoWriteChannel<T>, x: any, scheduler: Scheduler): Promise<undefined>
function goTrySend<T>(ch: GoWriteChannel<T>, x: any, scheduler: Scheduler): Promise<boolean>
function goClose<T>(ch: GoWriteChannel<T>, scheduler: Scheduler): Promise<undefined>
class SelectDir extends Native {
    private readonly __SelectDir: SelectDir
    private constructor() { }
}
const SelectSend: SelectDir
const SelectRecv: SelectDir
const SelectDefault: SelectDir
function NewSendCase(ch: GoWriteChannel, val: any): SelectCase
function NewRecvCase(ch: GoReadChannel): SelectCase
function NewSendCase(ch: GoWriteChannel, val: any, scheduler: Scheduler): Promise<SelectCase>
function NewRecvCase(ch: GoReadChannel, scheduler: Scheduler): Promise<SelectCase>
class SelectCase extends Native {
    private readonly __SelectCase: SelectCase
    private constructor() { }
}
const DefaultCase: SelectCase
function goSelect(...cases: Array<SelectCase>): [GoInt, any, boolean]
function goSelect(...cases: Array<SelectCase>, scheduler: Scheduler): Promise<[GoInt, any, boolean]>

class Scheduler extends Native {
    private readonly __Scheduler: Scheduler
    private constructor() { }
}
const DefaultScheduler: Scheduler
class GoErrorNative extends Native {
    private readonly __GoErrorNative: GoErrorNative
    private constructor()
    Error(): string
    Error(scheduler: Scheduler): Promise<string>
}
class GoError extends Native {
    private readonly __GoError: GoError
    private constructor()
    name: string
    message: string
    stack?: string
    value: GoErrorNative
}
class Completer<T> {
    constructor()
    get promise(): Promise<T>
    resolve(value?: T | PromiseLike<T>)
    reject(reason?: any)
    toString(): string
}
class GoMap extends Native {
    private readonly __GoMap: GoMap
    private constructor()
}
class GoSlice extends Native {
    private readonly __GoSlice: GoSlice
    private constructor()
}
function goLen(v: GoMap | GoSlice): GoInt
function goHasKey(v: GoMap, key: any): boolean
function isGoSlice(v: GoSlice): boolean
function isGoMap(v: GoMap): boolean
{{range.}}{{if .Max}}
const Max{{.Name}}: Go{{.Name}}{{end}}{{end}}{{range.}}{{if .Min}}
const Min{{.Name}}: Go{{.Name}}{{end}}{{end}}
{{range.}}
class Go{{.Name}} extends GoNumber {
    private readonly __Go{{.Name}}: Go{{.Name}}
    private constructor()
    String(): string
    ToNumber(): number{{range $item := $ctx}}
    To{{$item.Name}}(): Go{{$item.Name}}{{end}}{{if not .Uint}}
    ABS(): Go{{.Name}}
    Negate(): Go{{.Name}}{{end}}
    Add(...value: Array<NumberLike>): Go{{.Name}}
    Sub(...value: Array<NumberLike>): Go{{.Name}}
    Mul(...value: Array<NumberLike>): Go{{.Name}}
    Div(...value: Array<NumberLike>): Go{{.Name}}{{if .Integer}}
    Mod(...value: Array<NumberLike>): Go{{.Name}}
    And(...value: Array<NumberLike>): Go{{.Name}}
    AndNot(...value: Array<NumberLike>): Go{{.Name}}
    Not(): Go{{.Name}}
    Or(...value: Array<NumberLike>): Go{{.Name}}
    Xor(...value: Array<NumberLike>): Go{{.Name}}
    ShiftLeft(...value: Array<NumberLike>): Go{{.Name}}
    ShiftRight(...value: Array<NumberLike>): Go{{.Name}}{{else}}
    Sqrt(): Go{{.Name}}{{end}}
    Compare(val: NumberLike): number
    Max(...value: Array<NumberLike>): Go{{.Name}}
    Min(...value: Array<NumberLike>): Go{{.Name}}
}
function New{{.Name}}(val: NumberLike): Go{{.Name}}
function New{{.Name}}(val: string{{if .Integer}}, base: number | string{{end}}): Go{{.Name}}
function is{{.Name}}(v: any): v is {{.Name}}
{{end}}{{range.}}
class Go{{.Name}}Array extends GoSlice {
    private readonly __Go{{.Name}}Array: Go{{.Name}}Array
    private constructor()
    String(): string
    Len(): GoInt
    Swap(i: NumberLike, j: NumberLike)
    Less(i: NumberLike, j: NumberLike): boolean
    Cap(): GoInt
    Copy(src: Go{{.Name}}Array): GoInt
    Slice(start: NumberLike): Go{{.Name}}Array
    SliceEnd(start: NumberLike, end: NumberLike): Go{{.Name}}Array
    Append(...data: Array<NumberLike>): Go{{.Name}}Array
    Get(index: NumberLike): Go{{.Name}}
    Set(index: NumberLike, val: NumberLike)
    Join(sep: string): string
    Asc()
    Desc()
}
function New{{.Name}}Array(): Go{{.Name}}Array
function New{{.Name}}Array(len: NumberLike): Go{{.Name}}Array
function New{{.Name}}Array(len: NumberLike, cap: NumberLike): Go{{.Name}}Array
function is{{.Name}}Array(v: any): v is {{.Name}}Array{{end}}{{end}}

type GoRune = GoInt32
type GoBytes = GoUint8Array
type GoByte = GoUint8