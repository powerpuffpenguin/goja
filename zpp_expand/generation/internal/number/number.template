package goja{{with $ctx :=  .}}

import (
	"errors"
	"fmt"
	"math"
	"sort"
	"strconv"
	"strings"
)
{{range .}}
type {{.Name}} {{.Type}}

func New{{.Name}}(val {{.Type}}) {{.Name}} {
	return {{.Name}}(val)
}
func (v {{.Name}}) String() string {
	return fmt.Sprint({{.Type}}(v))
}
func (v {{.Name}}) Native() interface{} {
	return {{.Type}}(v)
}{{if .Integer}}
func (v {{.Name}}) ToNumber() Value {
	return intToValue(int64(v))
}{{else}}
func (v {{.Name}}) ToNumber() Value {
	return floatToValue(float64(v))
}{{end}}{{with $parent :=  .}}{{range $item := $ctx}}
func (v {{$parent.Name}}) To{{$item.Name}}() {{$item.Type}} {
	return {{$item.Type}}(v)
}{{end}}{{end}}{{if not .Uint}}
func (v {{.Name}}) ABS() {{.Type}} {
	result := {{.Type}}(v)
	if result < 0 {
		return -result
	}
	return result
}
func (v {{.Name}}) Negate() {{.Type}} {
	return {{.Type}}(-v)
}{{end}}
func (v {{.Name}}) Add(vals ...{{.Type}}) {{.Type}} {
	result := {{.Type}}(v)
	for _, val := range vals {
		result += val
	}
	return result
}
func (v {{.Name}}) Sub(vals ...{{.Type}}) {{.Type}} {
	result := {{.Type}}(v)
	for _, val := range vals {
		result -= val
	}
	return result
}
func (v {{.Name}}) Mul(vals ...{{.Type}}) {{.Type}} {
	result := {{.Type}}(v)
	for _, val := range vals {
		result *= val
	}
	return result
}
func (v {{.Name}}) Div(vals ...{{.Type}}) ({{.Type}}, error) {
	result := {{.Type}}(v)
	if result == 0 {
		return 0, nil
	}
	for _, val := range vals {
		if val == 0 {
			return 0, errors.New("divide by zero")
		}
		result /= val
	}
	return result, nil
}{{if .Integer}}
func (v {{.Name}}) Mod(vals ...{{.Type}}) ({{.Type}}, error) {
	result := {{.Type}}(v)
	if result == 0 {
		return 0, nil
	}
	for _, val := range vals {
		if val == 0 {
			return 0, errors.New("divide by zero")
		}
		result %= val
		if result == 0 {
			return 0, nil
		}
	}
	return result, nil
}
func (v {{.Name}}) And(vals ...{{.Type}}) {{.Type}} {
	result := {{.Type}}(v)
	for _, val := range vals {
		result &= val
	}
	return result
}
func (v {{.Name}}) AndNot(vals ...{{.Type}}) {{.Type}} {
	result := {{.Type}}(v)
	for _, val := range vals {
		result &= (^val)
	}
	return result
}
func (v {{.Name}}) Not() {{.Type}} {
	return ^{{.Type}}(v)
}
func (v {{.Name}}) Or(vals ...{{.Type}}) {{.Type}} {
	result := {{.Type}}(v)
	for _, val := range vals {
		result |= val
	}
	return result
}
func (v {{.Name}}) Xor(vals ...{{.Type}}) {{.Type}} {
	result := {{.Type}}(v)
	for _, val := range vals {
		result ^= val
	}
	return result
}
func (v {{.Name}}) ShiftLeft(vals ...int) {{.Type}} {
	result := {{.Type}}(v)
	for _, val := range vals {
		result <<= val
	}
	return result
}
func (v {{.Name}}) ShiftRight(vals ...int) {{.Type}} {
	result := {{.Type}}(v)
	for _, val := range vals {
		result >>= val
	}
	return result
}{{else}}
func (v {{.Name}}) Sqrt() {{.Type}} {
	result := math.Sqrt(float64(v))
	return {{ typeconv2 "float64" .Type "result" }}
}{{end}}
func (v {{.Name}}) Compare(val {{.Type}}) Value {
	current := {{.Type}}(v)
	if current == val {
		return intToValue(0)
	} else if current < val {
		return intToValue(-1)
	}
	return intToValue(1)
}
func (v {{.Name}}) Max(vals ...{{.Type}}) {{.Type}} {
	result := {{.Type}}(v)
	for _, val := range vals {
		if val > result {
			result = val
		}
	}
	return result
}
func (v {{.Name}}) Min(vals ...{{.Type}}) {{.Type}} {
	result := {{.Type}}(v)
	for _, val := range vals {
		if val < result {
			result = val
		}
	}
	return result
}
func (r *Runtime) builtinGo_is{{.Name}}(call FunctionCall) Value {
	_, result := call.Argument(0).Export().({{.Name}})
	if result {
		return valueTrue
	}
	return valueFalse
}
func (r *Runtime) builtinGo_New{{.Name}}(call FunctionCall) Value {
	var (
		result {{.Type}}
		args   = call.Arguments
		count  = len(call.Arguments)
	)
	if count > 0 {
		if s, ok := args[0].Export().(string); ok {
{{if .Integer}}			var base = 10
			if count > 1 {
				e := r.ExportTo(args[1], &base)
				if e != nil {
					panic(r.NewGoError(e))
				}
			}
			val, e := {{if .Uint}}strconv.ParseUint{{else}}strconv.ParseInt{{end}}(s, base, {{.BitSize}})
			if e !=nil {
				panic(r.NewGoError(e))
			}{{if .Uint}}
			result = {{ typeconv2 "uint64" .Type "val"}}{{else}}
			result = {{ typeconv2 "int64" .Type "val"}}{{end}}{{else}}			val, e := strconv.ParseFloat(s, {{.BitSize}})
			if e !=nil {
				panic(r.NewGoError(e))
			}
			result = {{ typeconv2 "float64" .Type "val"}}{{end}}
		} else {
			e := r.ExportTo(args[0], &result)
			if e != nil {
				panic(r.NewGoError(e))
			}
		}
	}
	return r.ToValue(New{{.Name}}(result))
}
{{end}}{{range .}}
type {{.Name}}Array []{{.Type}}

func New{{.Name}}Array(val []{{.Type}}) {{.Name}}Array {
	return {{.Name}}Array(val)
}
func (v {{.Name}}Array) String() string {
	return fmt.Sprint([]{{.Type}}(v))
}
func (v {{.Name}}Array) Native() interface{} {
	return []{{.Type}}(v)
}
func (v {{.Name}}Array) Len() int {
	return len(v)
}
func (v {{.Name}}Array) Swap(i, j int) {
	v[i], v[j] = v[j], v[i]
}
func (v {{.Name}}Array) Less(i, j int) bool {
	return v[i] < v[j]
}
func (v {{.Name}}Array) Cap() int {
	return cap(v)
}
func (v {{.Name}}Array) Copy(src []{{.Type}}) int {
	return copy(v, src)
}
func (v {{.Name}}Array) Slice(start int) []{{.Type}} {
	count := len(v)
	if count == 0 {
		return v[:]
	}
	if start < 0 {
		start = 0
	}
	return v[start:]
}
func (v {{.Name}}Array) SliceEnd(start, end int) []{{.Type}} {
	count := len(v)
	if count == 0 {
		return v[:]
	}
	if start < 0 {
		start = 0
	} else if start >= count {
		return v[count:]
	} else if end < start {
		return v[start:start]
	}
	return v[start:end]
}
func (v {{.Name}}Array) Append(data ...{{.Type}}) []{{.Type}} {
	return append(v, data...)
}
func (v {{.Name}}Array) Get(index int) ({{.Type}}, error) {
	if index < 0 || index >= len(v) {
		return 0, fmt.Errorf("slice bounds out of range get(%d)", index)
	}
	return {{.Type}}(v[index]), nil
}
func (v {{.Name}}Array) Set(index int, val {{.Type}}) error {
	if index < 0 || index >= len(v) {
		return fmt.Errorf("slice bounds out of range get(%d)", index)
	}
	v[index] = val
	return nil
}
func (v {{.Name}}Array) Join(sep string) string {
	var (
		result string
		count  = len(v)
	)
	if count > 0 {
		strs := make([]string, count)
		for i, val := range v {
			strs[i] = fmt.Sprint(val)
		}
		result = strings.Join(strs, sep)
	}
	return result
}
func (v {{.Name}}Array) Asc() {
	sort.Sort(v)
}
func (v {{.Name}}Array) Desc() {
	sort.Sort(sort{{.Name}}Array(v))
}

type sort{{.Name}}Array []{{.Type}}

func (a sort{{.Name}}Array) Len() int           { return len(a) }
func (a sort{{.Name}}Array) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a sort{{.Name}}Array) Less(i, j int) bool { return a[i] > a[j] }

func (r *Runtime) builtinGo_is{{.Name}}Array(call FunctionCall) Value {
	_, result := call.Argument(0).Export().({{.Name}}Array)
	if result {
		return valueTrue
	}
	return valueFalse
}
func (r *Runtime) builtinGo_New{{.Name}}Array(call FunctionCall) Value {
	var (
		result []{{.Type}}
		args   = call.Arguments
		count  = len(call.Arguments)
	)
	if count > 0 {
		var l int
		e := r.ExportTo(args[0], &l)
		if e != nil {
			panic(r.NewGoError(e))
		} else if l < 0 {
			l = 0
		}
		if count > 1 {
			var c int
			e := r.ExportTo(args[1], &c)
			if e != nil {
				panic(r.NewGoError(e))
			} else if c < l {
				c = l
			}
			result = make([]{{.Type}}, l, c)
		} else {
			result = make([]{{.Type}}, l)
		}
	}
	return r.ToValue(New{{.Name}}Array(result))
}
{{end}}
func (r *Runtime) pp_expand_init_number() {
{{range .}}	r.addToGlobal(`New{{.Name}}`, r.newNativeFunc(r.builtinGo_New{{.Name}}, nil, "New{{.Name}}", nil, {{if .Integer}}2{{else}}1{{end}}))
{{end}}{{range .}}{{if .Max}}	r.addToGlobal(`Max{{.Name}}`, r.ToValue(New{{.Name}}(math.Max{{.Name}})))
{{end}}{{end}}{{range .}}{{if .Min}}	r.addToGlobal(`Min{{.Name}}`, r.ToValue(New{{.Name}}(math.Min{{.Name}})))
{{end}}{{end}}	r.addToGlobal(`IntSize`, intToValue(strconv.IntSize)){{range .}}
	r.addToGlobal(`New{{.Name}}Array`, r.newNativeFunc(r.builtinGo_New{{.Name}}Array, nil, "New{{.Name}}Array", nil, 2)){{end}}
{{range .}}
	r.addToGlobal(`is{{.Name}}`, r.newNativeFunc(r.builtinGo_is{{.Name}}, nil, "is{{.Name}}", nil, 1))
	r.addToGlobal(`is{{.Name}}Array`, r.newNativeFunc(r.builtinGo_is{{.Name}}Array, nil, "is{{.Name}}Array", nil, 1)){{end}}
}
{{end}}