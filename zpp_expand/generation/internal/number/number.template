package goja{{with $ctx :=  .}}

import (
	"errors"
	"fmt"
	"math"
	"strconv"
)
{{range .}}
type {{.Name}} {{.Type}}

func New{{.Name}}(val {{.Type}}) {{.Name}} {
	return {{.Name}}(val)
}
func (v {{.Name}}) String() string {
	return fmt.Sprint({{.Type}}(v))
}{{if .Integer}}
func (v {{.Name}}) Native() int64 {
	return int64(v)
}
func (v {{.Name}}) ToNumber() Value {
	return intToValue(int64(v))
}{{else}}
func (v {{.Name}}) Native() float64 {
	return float64(v)
}
func (v {{.Name}}) ToNumber() Value {
	return floatToValue(float64(v))
}{{end}}{{with $parent :=  .}}{{range $item := $ctx}}
func (v {{$parent.Name}}) To{{$item.Name}}() {{$item.Type}} {
	return {{$item.Type}}(v)
}{{end}}{{end}}{{if not .Uint}}
func (v {{.Name}}) ABS() {{.Type}} {
	result := {{.Type}}(v)
	if result < 0 {
		return -result
	}
	return result
}
func (v {{.Name}}) Negate() {{.Type}} {
	return {{.Type}}(-v)
}{{end}}
func (v {{.Name}}) Add(vals ...{{.Type}}) {{.Type}} {
	result := {{.Type}}(v)
	for _, val := range vals {
		result += val
	}
	return result
}
func (v {{.Name}}) Sub(vals ...{{.Type}}) {{.Type}} {
	result := {{.Type}}(v)
	for _, val := range vals {
		result -= val
	}
	return result
}
func (v {{.Name}}) Mul(vals ...{{.Type}}) {{.Type}} {
	result := {{.Type}}(v)
	for _, val := range vals {
		result *= val
	}
	return result
}
func (v {{.Name}}) Div(vals ...{{.Type}}) ({{.Type}}, error) {
	result := {{.Type}}(v)
	if result == 0 {
		return 0, nil
	}
	for _, val := range vals {
		if val == 0 {
			return 0, errors.New("divide by zero")
		}
		result /= val
	}
	return result, nil
}{{if .Integer}}
func (v {{.Name}}) Mod(vals ...{{.Type}}) ({{.Type}}, error) {
	result := {{.Type}}(v)
	if result == 0 {
		return 0, nil
	}
	for _, val := range vals {
		if val == 0 {
			return 0, errors.New("divide by zero")
		}
		result %= val
		if result == 0 {
			return 0, nil
		}
	}
	return result, nil
}
func (v {{.Name}}) And(vals ...{{.Type}}) {{.Type}} {
	result := {{.Type}}(v)
	for _, val := range vals {
		result &= val
	}
	return result
}
func (v {{.Name}}) AndNot(vals ...{{.Type}}) {{.Type}} {
	result := {{.Type}}(v)
	for _, val := range vals {
		result &= (^val)
	}
	return result
}
func (v {{.Name}}) Not() {{.Type}} {
	return ^{{.Type}}(v)
}
func (v {{.Name}}) Or(vals ...{{.Type}}) {{.Type}} {
	result := {{.Type}}(v)
	for _, val := range vals {
		result |= val
	}
	return result
}
func (v {{.Name}}) Xor(vals ...{{.Type}}) {{.Type}} {
	result := {{.Type}}(v)
	for _, val := range vals {
		result ^= val
	}
	return result
}
func (v {{.Name}}) ShiftLeft(vals ...int) {{.Type}} {
	result := {{.Type}}(v)
	for _, val := range vals {
		result <<= val
	}
	return result
}
func (v {{.Name}}) ShiftRight(vals ...int) {{.Type}} {
	result := {{.Type}}(v)
	for _, val := range vals {
		result >>= val
	}
	return result
}{{else}}
func (v {{.Name}}) Sqrt() {{.Type}} {
	result := math.Sqrt(float64(v))
	return {{ typeconv2 "float64" .Type "result" }}
}{{end}}
func (v {{.Name}}) Compare(val {{.Type}}) Value {
	current := {{.Type}}(v)
	if current == val {
		return intToValue(0)
	} else if current < val {
		return intToValue(-1)
	}
	return intToValue(1)
}
func (v {{.Name}}) Max(vals ...{{.Type}}) {{.Type}} {
	result := {{.Type}}(v)
	for _, val := range vals {
		if val > result {
			result = val
		}
	}
	return result
}
func (v {{.Name}}) Min(vals ...{{.Type}}) {{.Type}} {
	result := {{.Type}}(v)
	for _, val := range vals {
		if val < result {
			result = val
		}
	}
	return result
}
func (r *Runtime) builtinGo_New{{.Name}}(call FunctionCall) Value {
	var (
		result {{.Type}}
		args   = call.Arguments
		count  = len(call.Arguments)
	)
	if count > 0 {
		if s, ok := args[0].Export().(string); ok {
{{if .Integer}}			var base = 10
			if count > 1 {
				e := r.ExportTo(args[1], &base)
				if e != nil {
					panic(r.NewGoError(e))
				}
			}
			val, e := {{if .Uint}}strconv.ParseUint{{else}}strconv.ParseInt{{end}}(s, base, {{.BitSize}})
			if e !=nil {
				panic(r.NewGoError(e))
			}{{if .Uint}}
			result = {{ typeconv2 "uint64" .Type "val"}}{{else}}
			result = {{ typeconv2 "int64" .Type "val"}}{{end}}{{else}}			val, e := strconv.ParseFloat(s, {{.BitSize}})
			if e !=nil {
				panic(r.NewGoError(e))
			}
			result = {{ typeconv2 "float64" .Type "val"}}{{end}}
		} else {
			e := r.ExportTo(args[0], &result)
			if e != nil {
				panic(r.NewGoError(e))
			}
		}
	}
	return r.ToValue(New{{.Name}}(result))
}
{{end}}{{range .}}
type {{.Name}}Array []{{.Type}}

func New{{.Name}}Array(val []{{.Type}}) {{.Name}}Array {
	return {{.Name}}Array(val)
}
func (v {{.Name}}Array) String() string {
	return fmt.Sprint([]{{.Type}}(v))
}
func (v {{.Name}}Array) Len() int {
	return len(v)
}
func (v {{.Name}}Array) Cap() int {
	return cap(v)
}
func (v {{.Name}}Array) Copy(src []{{.Type}}) int {
	return copy(v, src)
}
func (v {{.Name}}Array) Slice(start int) []{{.Type}} {
	count := len(v)
	if count == 0 {
		return v[:]
	}
	if start < 0 {
		start = 0
	}
	return v[start:]
}
func (v {{.Name}}Array) SliceEnd(start, end int) []{{.Type}} {
	count := len(v)
	if count == 0 {
		return v[:]
	}
	if start < 0 {
		start = 0
	} else if start >= count {
		return v[count:]
	} else if end < start {
		return v[start:start]
	}
	return v[start:end]
}
{{end}}
func (r *Runtime) pp_expand_init_number() {
{{range .}}	r.addToGlobal(`New{{.Name}}`, r.newNativeFunc(r.builtinGo_New{{.Name}}, nil, "New{{.Name}}", nil, {{if .Integer}}2{{else}}1{{end}}))
{{end}}{{range .}}{{if .Max}}	r.addToGlobal(`Max{{.Name}}`, r.ToValue(New{{.Name}}(math.Max{{.Name}})))
{{end}}{{end}}{{range .}}{{if .Min}}	r.addToGlobal(`Min{{.Name}}`, r.ToValue(New{{.Name}}(math.Min{{.Name}})))
{{end}}{{end}}	r.addToGlobal(`IntSize`, intToValue(strconv.IntSize))
}
{{end}}